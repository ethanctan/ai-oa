<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Interviewer</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      color: var(--vscode-editor-foreground);
      background-color: var(--vscode-editor-background);
    }
    #chat-log {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      border-bottom: 1px solid var(--vscode-panel-border);
    }
    #chat-form {
      display: flex;
      padding: 10px;
      background: var(--vscode-editor-inactiveSelectionBackground);
    }
    #chat-input {
      flex: 1;
      padding: 8px;
      font-size: 1rem;
      background-color: var(--vscode-input-background);
      color: var(--vscode-input-foreground);
      border: 1px solid var(--vscode-input-border);
      border-radius: 4px;
    }
    #chat-input:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #chat-submit {
      margin-left: 10px;
      padding: 8px 16px;
      font-size: 1rem;
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #chat-submit:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #chat-submit:hover:not(:disabled) {
      background-color: var(--vscode-button-hoverBackground);
    }
    .chat-message {
      margin-bottom: 16px;
      border-radius: 8px;
      padding: 10px 16px;
      max-width: 80%;
      word-wrap: break-word;
    }
    .user {
      background-color: var(--vscode-input-background, rgba(255,255,255,0.1));
      align-self: flex-end;
      margin-left: auto;
    }
    .interviewer {
      background-color: var(--vscode-editor-inactiveSelectionBackground, rgba(255,255,255,0.05));
      align-self: flex-start;
      margin-right: auto;
      color: var(--vscode-editor-foreground, #e7e7e7);
    }
    .chat-header {
      font-weight: bold;
      margin-bottom: 4px;
    }
    .chat-content {
      white-space: pre-wrap;
    }
    #interview-controls {
      display: flex;
      justify-content: center;
      padding: 8px;
      border-bottom: 1px solid var(--vscode-panel-border);
    }
    #start-final-interview {
      padding: 8px 16px;
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    #start-final-interview:hover {
      background-color: var(--vscode-button-hoverBackground);
    }
    .system-message {
      text-align: center;
      padding: 8px;
      margin: 8px 0;
      font-style: italic;
      color: var(--vscode-editorWarning-foreground);
    }
    #chat-log {
      display: flex;
      flex-direction: column;
    }
    #timer-container {
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 10px 0;
    }
    #timer {
      font-size: 16px;
      font-weight: bold;
      padding: 5px 10px;
      background-color: var(--vscode-editor-background);
      color: var(--vscode-editor-foreground);
      border-radius: 4px;
      margin-right: 10px;
    }
    .action-button {
      padding: 8px 12px;
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
    }
    .action-button:hover {
      background-color: var(--vscode-button-hoverBackground);
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px 10px;
      background-color: var(--vscode-editor-background);
      border-bottom: 1px solid var(--vscode-panel-border);
    }
    .title {
      font-weight: bold;
      font-size: 14px;
    }
    /* Add a style for expired timer */
    #timer.expired {
      background-color: var(--vscode-errorForeground, red);
      color: white;
    }
    .messages {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
    }
    .message {
      margin-bottom: 10px;
      padding: 8px 12px;
      border-radius: 5px;
      max-width: 80%;
      word-wrap: break-word;
    }
    .user-message {
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      margin-left: auto;
    }
    .ai-message {
      background-color: var(--vscode-editor-inactiveSelectionBackground);
      color: var(--vscode-editor-foreground);
    }
    .system-message {
      background-color: transparent;
      color: var(--vscode-descriptionForeground);
      font-style: italic;
      text-align: center;
      max-width: 100%;
      border-top: 1px solid var(--vscode-panel-border);
      border-bottom: 1px solid var(--vscode-panel-border);
      margin: 10px 0;
      padding: 5px 0;
    }
    .chat-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    #chat-form {
      display: flex;
      padding: 10px;
      border-top: 1px solid var(--vscode-panel-border);
    }
    #chat-input {
      flex: 1;
      padding: 8px;
      border: 1px solid var(--vscode-input-border);
      border-radius: 4px;
      background-color: var(--vscode-input-background);
      color: var(--vscode-input-foreground);
      resize: none;
    }
    #chat-submit {
      margin-left: 10px;
      padding: 8px 16px;
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #chat-submit:hover:not(:disabled) {
      background-color: var(--vscode-button-hoverBackground);
    }
    /* Additional styles for the timer info */
    .timer-info {
      padding: 8px 12px;
      background-color: var(--vscode-editorInfo-background, rgba(0,127,255,0.1));
      color: var(--vscode-editorInfo-foreground, #2040a0);
      text-align: center;
      font-size: 12px;
      border-bottom: 1px solid var(--vscode-panel-border);
    }
    
    /* Make timer info more prominent when timer is disabled */
    .timer-info.no-timer {
      font-size: 14px;
      padding: 12px 16px;
      background-color: var(--vscode-notificationsInfoIcon-background, rgba(0,127,255,0.2));
      border-radius: 4px;
      margin: 10px 20px;
      font-weight: bold;
    }
    /* Hidden class */
    .hidden {
      display: none !important;
    }
    /* Final interview button container */
    #final-interview-container {
      display: none;
      padding: 12px;
      text-align: center;
      border-top: 1px solid var(--vscode-panel-border);
    }
    
    #final-interview-container.visible {
      display: block;
    }

    #start-final-interview {
      padding: 10px 16px;
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      border-radius: 4px;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
    }

    #start-final-interview:hover {
      background-color: var(--vscode-button-hoverBackground);
    }
    
    /* Interview phase label */
    .phase-label {
      font-size: 12px;
      font-weight: bold;
      padding: 4px 8px;
      border-radius: 4px;
      display: inline-block;
      margin-bottom: 10px;
    }
    
    .phase-label.initial {
      background-color: var(--vscode-editorInfo-background, rgba(0,127,255,0.1));
      color: var(--vscode-editorInfo-foreground, #2040a0);
    }
    
    .phase-label.final {
      background-color: var(--vscode-editorWarning-background, rgba(255,127,0,0.1));
      color: var(--vscode-editorWarning-foreground, #a05000);
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(14, 112, 192, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(14, 112, 192, 0); }
      100% { box-shadow: 0 0 0 0 rgba(14, 112, 192, 0); }
    }
    
    /* Style for the Start Interview button when timer is disabled */
    .timer-container #start-interview {
      background-color: var(--vscode-button-prominentBackground, #0e70c0);
      color: var(--vscode-button-prominentForeground, white);
      font-weight: bold;
    }
    
    /* Special styling when timer is hidden */
    #timer.hidden + .action-button {
      background-color: var(--vscode-button-prominentBackground, #0e70c0);
      color: var(--vscode-button-prominentForeground, white);
      font-weight: bold;
      font-size: 16px;
      padding: 10px 16px;
      margin: 10px auto;
      animation: pulse 2s infinite;
    }
    
    /* Adjust timer container layout when timer is hidden */
    #timer-section {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* Project timer container */
    #project-timer-container {
      display: none;
      align-items: center;
      justify-content: center;
      margin: 10px 0;
      padding: 12px;
      border-top: 1px solid var(--vscode-panel-border);
      border-bottom: 1px solid var(--vscode-panel-border);
      background-color: var(--vscode-editorMarkerNavigationInfo-background, rgba(0, 100, 200, 0.1));
      text-align: center;
      width: 100%;
    }

    #project-timer-container.visible {
      display: flex !important;
    }

    #project-timer {
      font-size: 16px;
      font-weight: bold;
      padding: 5px 10px;
      background-color: var(--vscode-editor-background);
      color: var(--vscode-editor-foreground);
      border-radius: 4px;
      margin-right: 10px;
    }

    #project-timer.expired {
      background-color: var(--vscode-errorForeground, red);
      color: white;
    }

    /* Project phase label */
    .phase-label.project {
      background-color: var(--vscode-gitDecoration-addedResourceForeground, rgba(0,255,127,0.1));
      color: var(--vscode-gitDecoration-addedResourceForeground, #00a050);
    }
  </style>
</head>
<body>
  <div class="chat-container">
    <div class="header">
      <div class="title">AI Assessment</div>
      <div class="timer-container" id="timer-section">
        <div id="timer">10:00</div>
        <button id="start-interview" class="action-button">Start Interview</button>
      </div>
    </div>
    
    <div class="timer-info" id="timer-info">
      The timer starts automatically. You can start the interview at any time, or it will start automatically when the timer reaches zero.
    </div>
    
    <!-- Project timer container -->
    <div id="project-timer-container">
      <div style="display: flex; flex-direction: column; align-items: center;">
        <div style="font-weight: bold; margin-bottom: 4px;">Project Work Timer</div>
        <div id="project-timer" style="font-size: 24px; margin: 5px 0;">60:00</div>
        <div>Complete your implementation before the timer ends</div>
      </div>
    </div>
    
    <div class="messages" id="messages"></div>
    
    <div id="final-interview-container">
      <p>The initial interview is complete. When you are ready, submit your work and begin the final interview.</p>
      <button id="start-final-interview">Submit and Start Final Interview</button>
    </div>
    
    <form id="chat-form">
      <textarea id="chat-input" placeholder="Type your message..." rows="3" disabled></textarea>
      <button id="chat-submit" type="submit" disabled>Send</button>
    </form>
  </div>
  
  <script>
    (function() {
      const vscode = acquireVsCodeApi(); // VS Code API for message passing
      const messagesContainer = document.getElementById('messages');
      const chatForm = document.getElementById('chat-form');
      const chatInput = document.getElementById('chat-input');
      const chatSubmit = document.getElementById('chat-submit'); 
      const startInterviewBtn = document.getElementById('start-interview');
      const timerElement = document.getElementById('timer');
      const timerSection = document.getElementById('timer-section');
      const timerInfo = document.getElementById('timer-info');
      const finalInterviewContainer = document.getElementById('final-interview-container');
      const startFinalInterviewBtn = document.getElementById('start-final-interview');
      const projectTimerContainer = document.getElementById('project-timer-container');
      const projectTimerElement = document.getElementById('project-timer');

      // Global variables to store chat history, workspace context, and prompts
      let chatHistory = [];
      let workspaceContext = '';
      let initialPrompt = '';
      let finalPrompt = '';
      let assessmentPrompt = '';
      let initialInterviewStarted = false;
      let finalInterviewStarted = false;
      let initialInterviewEnded = false;
      let projectWorkStarted = false;
      let timerStarted = false;
      let timerEndTime = null;
      let timerInterval = null;
      let projectTimerEndTime = null;
      let projectTimerInterval = null;
      let instanceId = null;
      let currentInterviewPhase = 'initial'; // 'initial', 'project', or 'final'
      let finalInterviewTrulyEnded = false; // Flag for permanent disable after final END

      // Immediately request environment prompts
      vscode.postMessage({ command: 'getEnvironmentPrompts' });

      // Appends a message to the chat log and record it in chatHistory.
      function appendMessage(role, text, isSystemMessage = false) {
        // Ensure we have a valid container to append to
        if (!messagesContainer) {
          console.error('Error: Message container not found');
          return chatHistory;
        }
        
        const messageElem = document.createElement('div');
        
        if (isSystemMessage) {
          messageElem.className = 'system-message';
          messageElem.textContent = text;
        } else {
          messageElem.className = `message ${role === 'user' ? 'user-message' : 'ai-message'}`;
          
          // Add phase label for non-system messages
          // Only add labels at the beginning of an interview phase
          if (finalInterviewStarted && !initialInterviewEnded && !document.querySelector('.phase-label.final')) {
            const phaseLabel = document.createElement('div');
            phaseLabel.className = 'phase-label final';
            phaseLabel.textContent = 'Final Interview';
            messagesContainer.appendChild(phaseLabel);
          } else if (!finalInterviewStarted && !initialInterviewEnded && !document.querySelector('.phase-label.initial') && chatHistory.length === 0) {
            // Add initial phase label for the first message
            const phaseLabel = document.createElement('div');
            phaseLabel.className = 'phase-label initial';
            phaseLabel.textContent = 'Initial Interview';
            messagesContainer.appendChild(phaseLabel);
          }
          
          const contentElem = document.createElement('div');
          contentElem.className = 'message-content';
          contentElem.textContent = text;
          
          messageElem.appendChild(contentElem);
          
          // Determine current phase for the message
          const currentPhase = finalInterviewStarted ? 'final' : 'initial';
          
          // Record message in history
          const messageObj = { 
            role: role === 'user' ? 'user' : 'assistant', 
            content: text,
            phase: currentPhase
          };
          chatHistory.push(messageObj);
          console.log(`Added ${role} message to chatHistory. Length now: ${chatHistory.length}, phase: ${currentPhase}`);
        }
        
        messagesContainer.appendChild(messageElem);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
        return chatHistory;
      }

      // Start the initial interview
      function startInitialInterview() {
        if (initialInterviewStarted) return;
        initialInterviewStarted = true;
        
        // Show a system message indicating the start of the initial interview
        appendMessage('system', 'Initial Interview Started', true);
        
        // Add a loading message while we wait for the AI's first question
        const loadingMessageId = 'loading-message';
        const loadingMessage = document.createElement('div');
        loadingMessage.id = loadingMessageId;
        loadingMessage.className = 'system-message';
        loadingMessage.textContent = 'Waiting for interviewer to ask the first question...';
        messagesContainer.appendChild(loadingMessage);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
        // Hide the timer and timer info when interview starts
        timerSection.classList.add('hidden');
        timerInfo.classList.add('hidden');
        
        // Disable the input while waiting for first question
        chatInput.disabled = true;
        chatSubmit.disabled = true;
        
        // Notify the server that the interview has started
        vscode.postMessage({
          command: 'startInterview',
          instanceId
        });
        
        // Send an automatic first message
        setTimeout(() => {
          // Automatically send the first message from the user
          const initialUserMessage = "I am ready to start the initial interview.";
          
          // Add user message to the UI
          appendMessage('user', initialUserMessage);
          
          // Build complete messages array including system prompts and chat history
          const systemMessages = [];
          
          // Add the specific interview prompt if provided
          if (initialPrompt) {
            systemMessages.push({ role: "system", content: initialPrompt + " Based on the candidate's responses and the progress of the interview, decide whether to ask the next question or end the interview. If you decide the interview has covered enough topics and should conclude, respond with 'END' as your complete message. Otherwise, ask your next question." });
          } else {
            // Default system message
            systemMessages.push({ role: "system", content: 'You are a technical interviewer assessing a software engineering candidate. They have been provided with a coding project. Interview them about their design decisions and implementation. IMPORTANT: Ask only ONE question at a time, and wait for their response before asking the next question. Keep your questions concise and focused. Based on the candidate\'s responses and the progress of the interview, decide whether to ask the next question or end the interview. If you decide the interview has covered enough topics and should conclude, respond with \'END\' as your complete message. Otherwise, ask your next question.' });
          }
          
          // Always include workspace content if available
          if (workspaceContext) {
            systemMessages.push({ role: "system", content: "Project workspace content: " + workspaceContext });
          }
          
          // Construct the payload with all messages using the standardized format
          const payload = {
              "messages": [
                ...systemMessages,
                { role: "user", content: initialUserMessage }
              ]
          };
          
          // Send message to extension using the standard message sending channel
          vscode.postMessage({
            command: 'chatMessage',
            payload: payload,
            instanceId
          });
        }, 500); // Short delay to ensure interview started is processed first
      }

      // Retrieve all files in the workspace
      function requestWorkspaceContext() {
        vscode.postMessage({ command: 'getWorkspaceContent' });
      }
      
      // Retrieve all files immediately then every 30 seconds (reduced frequency to be less intrusive)
      requestWorkspaceContext();
      setInterval(requestWorkspaceContext, 30000);

      // Function to check if timer already exists and get status upon initial load
      function checkTimerStatus() {
        if (!instanceId) {
          console.log('Cannot check timer: No instance ID available');
          return;
        }
        
        console.log(`Checking if timer exists for instance ${instanceId}`);
        vscode.postMessage({ command: 'getTimerStatus', instanceId });
      }
      
      // Function to get timer status as a promise
      function getTimerStatus() {
        return new Promise((resolve, reject) => {
          if (!instanceId) {
            reject(new Error('No instance ID available'));
            return;
          }
          
          // Create a one-time event listener for the timer status response
          const listener = (event) => {
            if (event.data.command === 'timerStatus') {
              // Remove the event listener
              window.removeEventListener('message', listener);
              resolve(event.data.data);
            }
          };
          
          // Add the event listener
          window.addEventListener('message', listener);
          
          // Request the timer status
          vscode.postMessage({ command: 'getTimerStatus', instanceId });
          
          // Set a timeout to reject the promise if no response is received
          setTimeout(() => {
            window.removeEventListener('message', listener);
            reject(new Error('Timer status request timed out'));
          }, 5000);
        });
      }

      // Function to handle timer status updates from the server
      function handleTimerStatus(data) {
        console.log('Received timer status:', data);
        
        if (data.error) {
          console.error('Timer error:', data.error);
          timerElement.textContent = 'Timer error';
          return;
        }
        
        // Check if this is a project timer
        if (data.timerType === 'project') {
          handleProjectTimerStatus(data);
          return;
        }
        
        // Update the global timer end time
        if (data.endTimeMs) {
          timerEndTime = data.endTimeMs;
          console.log(`Timer end time set to: ${new Date(timerEndTime).toISOString()}`);
        }
        
        // Check if interview is already marked as started
        if (data.interviewStarted) {
          console.log('Interview already started according to server');
          initialInterviewStarted = true;
          
          // Hide timer UI
          timerSection.classList.add('hidden');
          timerInfo.classList.add('hidden');
          
          // Enable chat input
          chatInput.disabled = false;
          chatSubmit.disabled = false;
          
          // Update input state based on phase
          updateInputStateBasedOnPhase();
          
          return; // Exit early if interview already started
        }
        
        // Check if timer is active or disabled
        if (data.hasOwnProperty('active') && !data.active) {
          console.log('Timer is disabled - waiting for user to start interview manually');
          
          // Hide the timer element completely
          timerElement.classList.add('hidden');
          
          // Update timer info message
          timerInfo.textContent = 'Familiarize yourself with the workspace, then click "Start Interview" to begin when you are ready.';
          timerInfo.classList.add('no-timer');
          
          // Make sure start interview button is visible
          startInterviewBtn.classList.remove('hidden');
          
          // Mark timer as started but not running
          timerStarted = true;
          return; // Exit early since no timer is running
        }
        
        // Set up timer display updates
        updateTimerDisplay();
        
        // Clear any existing interval to prevent duplicates
        if (timerInterval) {
          clearInterval(timerInterval);
        }
        
        // Start a new interval for timer updates
        timerInterval = setInterval(updateTimerDisplay, 1000);
        
        // Mark timer as started
        timerStarted = true;
      }

      // Function to handle project timer status updates
      function handleProjectTimerStatus(data) {
        console.log('Received project timer status:', data);
        
        if (data.error) {
          console.error('Project timer error:', data.error);
          projectTimerElement.textContent = 'Timer error';
          return;
        }
        
        // Debug info - log all data received
        console.log('PROJECT TIMER DEBUG - Full data:', JSON.stringify(data));
        
        // Update the global project timer end time
        if (data.endTimeMs) {
          projectTimerEndTime = data.endTimeMs;
          console.log(`Project timer end time set to: ${new Date(projectTimerEndTime).toISOString()}`);
        }
        
        // Show project timer container - ensure it's visible
        projectTimerContainer.classList.add('visible');
        console.log('Project timer container visibility:', 
          projectTimerContainer.classList.contains('visible'), 
          'Display style:', window.getComputedStyle(projectTimerContainer).display);
        
        // Force visibility after a delay (helps with rendering issues)
        setTimeout(() => {
          projectTimerContainer.style.display = 'flex';
          console.log('Forced project timer display style to flex');
        }, 100);
        
        // Mark the current phase as project
        currentInterviewPhase = 'project';
        projectWorkStarted = true;
        initialInterviewEnded = true; // Ensure initial interview is marked as ended
        
        // IMPORTANT: Always disable chat input during project phase
        console.log('DISABLING CHAT INPUT: Project timer detected');
        chatInput.disabled = true;
        chatSubmit.disabled = true;
        
        // Ensure UI state is consistent with project phase
        updateInputStateBasedOnPhase();
        
        // Show final interview container to allow early submission
        finalInterviewContainer.classList.add('visible');
        
        // Check if the final interview has already started
        if (data.finalInterviewStarted) {
          console.log('Final interview already started according to server, not starting project timer interval.');
          // State already handled by updateInputStateBasedOnPhase
          return;
        }
        
        // Set up project timer display updates
        updateProjectTimerDisplay(); // Call once immediately

        // Clear any existing interval to prevent duplicates
        if (projectTimerInterval) {
          clearInterval(projectTimerInterval);
        }

        // Start a new interval for project timer updates
        console.log('Starting project timer interval...');
        projectTimerInterval = setInterval(updateProjectTimerDisplay, 1000);
      }

      // Update project timer display
      function updateProjectTimerDisplay() {
        if (!projectTimerEndTime) {
          console.log('No project timer end time available');
          return;
        }
        
        const now = Date.now();
        const timeLeft = Math.max(0, projectTimerEndTime - now);
                
        // Format the time remaining
        const minutes = Math.floor(timeLeft / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        projectTimerElement.textContent = display;
        
        // Check if timer expired
        if (timeLeft <= 0) {
          clearInterval(projectTimerInterval);
          projectTimerElement.textContent = '0:00';
          projectTimerElement.classList.add('expired');
          console.log('Project timer expired');
          
          // Auto-start final interview if timer expires
          if (!finalInterviewStarted) {
            startFinalInterview();
          }
        }
      }

      // Start the project work phase
      function startProjectWork() {
        if (projectWorkStarted) {
          console.log('Project work already started');
          return;
        }
        
        console.log('Starting project work phase');
        
        // Stop the initial timer interval if it's running
        if (timerInterval) {
          console.log('Clearing initial timer interval');
          clearInterval(timerInterval);
          timerInterval = null; // Reset interval variable
        }
        
        // Mark initial interview as ended
        initialInterviewEnded = true;
        projectWorkStarted = true;
        currentInterviewPhase = 'project';
        
        // Immediately make project timer container visible
        projectTimerContainer.classList.add('visible');
        projectTimerContainer.style.display = 'flex';
        console.log('Forcing project timer container visibility:', 
          projectTimerContainer.classList.contains('visible'), 
          'Style:', projectTimerContainer.style.display);
        
        // Add a direct manual fix to ensure the container is displayed
        document.querySelectorAll('#project-timer-container').forEach(el => {
          el.style.display = 'flex';
          console.log('Applied direct style on project-timer-container:', el);
        });
        
        // Add system message indicating start of project work phase
        appendMessage('system', 'Initial interview completed. Please implement your solution now. You can submit your work and start the final interview at any time.', true);
        
        // Notify server to start project timer
        vscode.postMessage({
          command: 'startProjectTimer',
          instanceId
        });
        
        // Save the project phase to the server
        vscode.postMessage({
          command: 'saveInterviewPhase',
          instanceId,
          phase: 'project_started'
        });
        
        // Disable chat input during project work
        chatInput.disabled = true;
        chatSubmit.disabled = true;
        
        // Show final interview container to allow early submission
        finalInterviewContainer.classList.add('visible');
        
        // Send a debug log to ensure communication is working
        setTimeout(() => {
          console.log('DEBUG: Checking if project timer container is visible after delay', 
            window.getComputedStyle(projectTimerContainer).display);
        }, 500);
      }

      // Function to handle chat history
      function handleChatHistory(history) {
        console.log(`Received chat history with ${history?.length || 0} messages`);
        
        // Don't try to process empty history
        if (!history || !Array.isArray(history) || history.length === 0) {
          console.log('No chat history to display or invalid history format');
          return;
        }
        
        // Debug log entire history for diagnosis
        console.log('Full history object:', JSON.stringify(history));
        
        // Clear any existing messages first
        messagesContainer.innerHTML = '';
        chatHistory = [];
        
        // Detect interview phases from history
        let foundInitialEnd = false;
        let foundFinalStart = false;
        let foundProjectPhase = false;
        let detectedPhase = 'initial';
        
        // First pass - check for phase markers and END messages
        for (let i = 0; i < history.length; i++) {
          const message = history[i];
          
          // Skip invalid messages
          if (!message.role || !message.content) continue;
          
          // Check for END messages
          if (message.role === 'assistant' && message.content.trim() === 'END') {
            if (detectedPhase === 'initial') {
              foundInitialEnd = true;
              detectedPhase = 'between'; // Between initial and final
              console.log('Detected end of initial interview in history');
            } else if (detectedPhase === 'final') {
              console.log('Detected end of final interview in history - setting TrulyEnded flag.');
              finalInterviewTrulyEnded = true; // Set the flag when final END is found in history
              // Submit final report when final interview ends
              submitFinalReport();
            }
          }
          
          // Check for phase markers
          if (message.role === 'system' && message.content.startsWith('PHASE_MARKER:')) {
            const phase = message.content.replace('PHASE_MARKER:', '').trim();
            console.log(`Found phase marker: ${phase}`);
            
            if (phase === 'initial') {
              detectedPhase = 'initial';
            } else if (phase === 'final' || phase === 'final_started') {
              detectedPhase = 'final';
              foundFinalStart = true;
            } else if (phase === 'project' || phase === 'project_started') {
              detectedPhase = 'project';
              foundProjectPhase = true;
              console.log('Detected project phase from history');
            }
          }
          
          // Also check for metadata
          if (message.metadata && message.metadata.phase) {
            console.log(`Found message with phase metadata: ${message.metadata.phase}`);
            if (message.metadata.phase === 'final') {
              detectedPhase = 'final';
              foundFinalStart = true;
            } else if (message.metadata.phase === 'project') {
              detectedPhase = 'project';
              foundProjectPhase = true;
            }
          }
          
          // Check for project phase message content
          if (message.role === 'system' && 
              (message.content.includes('Beginning project work phase') || 
               message.content.includes('Initial interview completed. Please implement your solution'))) {
            console.log('Detected project phase from system message content');
            detectedPhase = 'project';
            foundProjectPhase = true;
            foundInitialEnd = true;
          }
        }
        
        // Set global state based on detected phases
        initialInterviewStarted = true; // If we have chat history, initial must have started
        
        if (foundInitialEnd || foundProjectPhase) {
          initialInterviewEnded = true;
          console.log('Setting initialInterviewEnded=true based on history');
        }
        
        if (foundProjectPhase) {
          projectWorkStarted = true;
          currentInterviewPhase = 'project';
          console.log('Setting projectWorkStarted=true based on history');
        }
        
        if (foundFinalStart) {
          finalInterviewStarted = true;
          console.log('Setting finalInterviewStarted=true based on history');
        }
        
        // Second pass - add messages to UI
        let addedInitialPhaseLabel = false;
        let addedProjectPhaseLabel = false;
        let addedFinalPhaseLabel = false;
        let currentPhase = 'initial';
        let messagesAdded = 0;
        
        history.forEach((message, index) => {
          try {
            // Check for required fields
            if (!message.role || !message.content) {
              console.warn(`Skipping invalid message at index ${index}: missing role or content`);
              return;
            }
            
            // Skip system phase marker messages
            if (message.role === 'system' && message.content.startsWith('PHASE_MARKER:')) {
              console.log(`Skipping phase marker message: ${message.content}`);
              
              // Update current phase for next messages
              const phase = message.content.replace('PHASE_MARKER:', '').trim();
              if (phase === 'final' || phase === 'final_started') {
                currentPhase = 'final';
              } else if (phase === 'project' || phase === 'project_started') {
                currentPhase = 'project';
              }
              
              return;
            }
            
            // Handle END messages specially
            if (message.role === 'assistant' && message.content.trim() === 'END') {
              if (currentPhase === 'initial') {
                // Add system message instead of showing "END"
                const systemElem = document.createElement('div');
                systemElem.className = 'system-message';
                systemElem.textContent = 'The interviewer has concluded the initial interview. Thank you for your responses!';
                messagesContainer.appendChild(systemElem);
                
                // This marks the transition to final phase
                currentPhase = 'project';
              } else if (currentPhase === 'final') {
                // Add system message for final END
                const systemElem = document.createElement('div');
                systemElem.className = 'system-message';
                systemElem.textContent = 'Final interview complete. Thank you for your participation. You may now safely close this window.';
                messagesContainer.appendChild(systemElem);
              }
              
              // Still add to history for context but as a system message
              chatHistory.push({
                role: 'system',
                content: message.content,
                phase: currentPhase
              });
              
              messagesAdded++;
              return;
            }
            
            // Add phase labels at appropriate points
            if (currentPhase === 'initial' && !addedInitialPhaseLabel) {
              const phaseLabel = document.createElement('div');
              phaseLabel.className = 'phase-label initial';
              phaseLabel.textContent = 'Initial Interview';
              messagesContainer.appendChild(phaseLabel);
              addedInitialPhaseLabel = true;
            } else if (currentPhase === 'project' && !addedProjectPhaseLabel) {
              const phaseLabel = document.createElement('div');
              phaseLabel.className = 'phase-label project';
              phaseLabel.textContent = 'Project Implementation';
              messagesContainer.appendChild(phaseLabel);
              addedProjectPhaseLabel = true;
            } else if (currentPhase === 'final' && !addedFinalPhaseLabel) {
              const phaseLabel = document.createElement('div');
              phaseLabel.className = 'phase-label final';
              phaseLabel.textContent = 'Final Interview';
              messagesContainer.appendChild(phaseLabel);
              addedFinalPhaseLabel = true;
            }
            
            // Create normal message element
            const messageElem = document.createElement('div');
            messageElem.className = `message ${message.role === 'user' ? 'user-message' : 'ai-message'}`;
            
            // Create content element
            const contentElem = document.createElement('div');
            contentElem.className = 'message-content';
            contentElem.textContent = message.content;
            
            // Add content to message
            messageElem.appendChild(contentElem);
            
            // Add to UI
            messagesContainer.appendChild(messageElem);
            
            // Update message phase based on our current detected phase
            let messagePhase = message.metadata?.phase || currentPhase;
            
            // Add to chat history array
            chatHistory.push({
              role: message.role,
              content: message.content,
              phase: messagePhase
            });
            
            messagesAdded++;
          } catch (err) {
            console.error(`Error processing message ${index}:`, err);
          }
        });
        
        console.log(`Successfully restored ${messagesAdded} messages from history`);
        console.log(`Interview phases - Initial: ${initialInterviewStarted}, Initial ended: ${initialInterviewEnded}, Project: ${projectWorkStarted}, Final: ${finalInterviewStarted}`);
        
        // Update UI based on detected state
        if (projectWorkStarted && !finalInterviewStarted) {
          // We're in the project phase
          console.log('UI update: Project phase detected from history');
          finalInterviewContainer.classList.add('visible');
          chatInput.disabled = true;
          chatSubmit.disabled = true;
          
          // Make sure project timer container is visible
          projectTimerContainer.classList.add('visible');
          projectTimerContainer.style.display = 'flex';
        } else if (initialInterviewEnded && !finalInterviewStarted) {
          // Initial interview ended but not in project phase yet
          console.log('UI update: Initial interview ended, waiting for project phase');
          finalInterviewContainer.classList.add('visible');
          chatInput.disabled = true;
          chatSubmit.disabled = true;
        } else if (finalInterviewStarted) {
          // Final interview is ongoing
          console.log('UI update: Final interview phase');
          chatInput.disabled = false;
          chatSubmit.disabled = false;
          
          // Hide project UI if still visible
          projectTimerContainer.classList.remove('visible');
          finalInterviewContainer.classList.remove('visible');
        } else if (initialInterviewStarted) {
          // Initial interview is ongoing
          console.log('UI update: Initial interview phase');
          chatInput.disabled = false;
          chatSubmit.disabled = false;
        }
        
        // Scroll to the bottom
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
        // Make sure UI state is consistent after loading history
        setTimeout(updateInputStateBasedOnPhase, 500);
      }

      // Listen for messages from the extension
      window.addEventListener('message', (event) => {
        const message = event.data;
        console.log(`Received message from extension: ${message.command}`);
        
        // Handle workspace content received
        if (message.command === 'workspaceContent') {
          if (message.error) {
            console.error('Error getting workspace content:', message.error);
          } else {
            workspaceContext = message.content;
            console.log(`Received workspace content, length: ${workspaceContext.length}`);
          }
        }
        // Handle environment prompts received
        else if (message.command === 'environmentPrompts') {
          if (message.error) {
            console.error('Error getting environment prompts:', message.error);
          } else {
            initialPrompt = message.initialPrompt || '';
            finalPrompt = message.finalPrompt || '';
            assessmentPrompt = message.assessmentPrompt || '';
            instanceId = message.instanceId;
            
            console.log(`Received environment prompts. Initial prompt length: ${initialPrompt.length}`);
            console.log(`Instance ID: ${instanceId}`);
            
            // Check timer status if instance ID is available
            if (instanceId) {
              checkTimerStatus();
              
              // Also fetch chat history if available
              vscode.postMessage({ command: 'getChatHistory', instanceId });
              
              // Force update of input state
              setTimeout(updateInputStateBasedOnPhase, 1000);
            }
          }
        }
        // If we get timer status from server
        else if (message.command === 'timerStatus') {
          handleTimerStatus(message.data);
        }
        // Handle project timer status received
        else if (message.command === 'projectTimerStatus') {
          console.log('Received projectTimerStatus message from extension');
          handleProjectTimerStatus(message.data);
        }
        // Handle project work started event
        else if (message.command === 'projectWorkStarted') {
          console.log('Received projectWorkStarted message from extension');
          
          // Update state
          projectWorkStarted = true;
          initialInterviewEnded = true;
          currentInterviewPhase = 'project';
          
          // Force display of project timer container
          projectTimerContainer.classList.add('visible');
          setTimeout(() => {
            projectTimerContainer.style.display = 'flex';
            console.log('Forced project timer container display to flex after projectWorkStarted');
          }, 100);
          
          // Disable chat input during project work
          chatInput.disabled = true;
          chatSubmit.disabled = true;
          
          // Show final interview container to allow submission when ready
          finalInterviewContainer.classList.add('visible');
          
          // Ensure UI state is consistent with project phase
          updateInputStateBasedOnPhase();
        }
        // Handle chat message received
        else if (message.command === 'chatMessage') {
          // Remove loading message if it exists
          const loadingMessage = document.getElementById('loading-message');
          if (loadingMessage) {
            loadingMessage.remove();
          }
          
          const messageText = message.text;
          
          // Check if the AI is ending the interview with "END"
          if (messageText.trim() === 'END') {
            console.log('AI has decided to end the initial interview');
            appendMessage('system', 'Initial interview complete. Beginning project phase...', true);
            
            // Start the project phase
            startProjectWork();
          } else {
            // Normal AI message
            appendMessage('assistant', messageText);
          }
          
          // Enable input based on current phase
          if (finalInterviewStarted) {
            // Always enable input during final interview
            console.log('Enabling chat input for final interview phase (via chatMessage)');
            chatInput.disabled = false;
            chatSubmit.disabled = false;
          } else if (projectWorkStarted) {
            // Always disable in project phase
            console.log('Disabling chat input for project phase (via chatMessage)');
            chatInput.disabled = true;
            chatSubmit.disabled = true;
          } else if (initialInterviewStarted && !initialInterviewEnded) {
            // Enable in initial interview phase
            console.log('Enabling chat input for initial interview phase (via chatMessage)');
            chatInput.disabled = false;
            chatSubmit.disabled = false;
          }
        }
        // Handle chatResponse command - used for direct AI responses
        else if (message.command === 'chatResponse') {
          console.log('Received chatResponse:', message);
          
          // Remove loading message if it exists
          const loadingMessage = document.getElementById('loading-message');
          if (loadingMessage) {
            loadingMessage.remove();
          }
          
          if (message.error) {
            // Show error as system message
            console.error('Chat response error:', message.error);
            appendMessage('system', `Error: ${message.error}`, true);
          } else if (message.reply) {
            // Check if the AI is ending the interview with "END"
            if (message.reply.trim() === 'END') {
              console.log('AI has decided to end the interview with "END" message');
              
              // If in initial phase, start project work
              if (!finalInterviewStarted && !initialInterviewEnded) {
                appendMessage('system', 'Interview complete. Moving to next phase...', true);

                // Stop the initial timer interval before starting project work
                if (timerInterval) {
                  console.log('Clearing initial timer interval before starting project work');
                  clearInterval(timerInterval);
                  timerInterval = null;
                }
                startProjectWork();
              } else {
                // In final phase, show completion message and permanently disable input
                appendMessage('system', 'Final interview complete. Thank you for your participation. You may now safely close this window.', true);
                finalInterviewTrulyEnded = true;
                // Submit final report when final interview ends
                submitFinalReport();
                updateInputStateBasedOnPhase(); // Immediately disable input
              }
            } else {
              // Normal AI message
              appendMessage('assistant', message.reply);
            }
          }
          
          // Enable input based on current phase
          if (finalInterviewStarted) {
            // Always enable input during final interview
            console.log('Enabling chat input for final interview phase');
            chatInput.disabled = false;
            chatSubmit.disabled = false;
          } else if (projectWorkStarted) {
            // Always disable in project phase
            console.log('Disabling chat input for project phase');
            chatInput.disabled = true;
            chatSubmit.disabled = true;
          } else if (initialInterviewStarted && !initialInterviewEnded) {
            // Enable in initial interview phase
            console.log('Enabling chat input for initial interview phase');
            chatInput.disabled = false;
            chatSubmit.disabled = false;
          }
        }
        // Handle chat history received
        else if (message.command === 'chatHistory') {
          if (message.error) {
            console.error('Error retrieving chat history:', message.error);
          } else if (message.history) {
            console.log(`Received chat history with ${message.history.length} messages. Processing...`);
            handleChatHistory(message.history);
            
            // If there's chat history, the interview must have started
            if (message.interviewStarted || (message.history && message.history.length > 0)) {
              initialInterviewStarted = true;
              
              // Hide timer UI
              timerSection.classList.add('hidden');
              timerInfo.classList.add('hidden');
              
              // Enable chat input
              chatInput.disabled = false;
              chatSubmit.disabled = false;
            }
          } else {
            console.log('Received chatHistory command but no history was included');
          }
        }
        // Handle interview started confirmation
        else if (message.command === 'interviewStarted') {
          console.log('Interview started status confirmed by server');
          initialInterviewStarted = true;
          
          // Hide timer UI
          timerSection.classList.add('hidden');
          timerInfo.classList.add('hidden');
          
          // Enable chat input
          chatInput.disabled = false;
          chatSubmit.disabled = false;
          
          // Update timer status if provided
          if (message.timer) {
            handleTimerStatus(message.timer);
          }
        }
        // Handle final interview started confirmation
        else if (message.command === 'finalInterviewStarted') {
          console.log('Final interview started status confirmed by server');
          finalInterviewStarted = true;
          currentInterviewPhase = 'final';
          
          // Hide project timer if visible
          projectTimerContainer.classList.remove('visible');
          
          // Enable chat input for final interview
          chatInput.disabled = false;
          chatSubmit.disabled = false;
        }
      });

      // Set up form submission
      chatForm.addEventListener('submit', (e) => {
        e.preventDefault();
        
        const messageText = chatInput.value.trim();
        if (!messageText) return;
        
        console.log(`User submitting message: "${messageText}"`);
        
        // Disable input while waiting for response
        chatInput.disabled = true;
        chatSubmit.disabled = true;
        
        // Add user message to chat UI and history
        appendMessage('user', messageText);
        
        // Log the state of chatHistory
        console.log(`Chat history after adding message. Length: ${chatHistory.length}`);
        if (chatHistory.length > 0) {
          console.log(`Last message in history: role=${chatHistory[chatHistory.length-1].role}, content=${chatHistory[chatHistory.length-1].content.substring(0, 30)}...`);
        }
        
        // Build complete messages array including system prompts and chat history
        const systemMessages = [];
        
        // Base prompt depending on interview stage
        let basePrompt = '';
        if (initialInterviewStarted && finalInterviewStarted) {
          // Final interview mode
          basePrompt = finalPrompt;
        } else if (initialInterviewStarted) {
          // Initial interview mode
          basePrompt = initialPrompt;
        } else {
          // Default system message
          basePrompt = 'You are a technical interviewer assessing a software engineering candidate. They have been provided with a coding project. Interview them about their design decisions and implementation. IMPORTANT: Ask only ONE question at a time, and wait for their response before asking the next question. Keep your questions concise and focused.';
        }
        
        // Add instruction to end interview when appropriate
        const endingInstructions = " Based on the candidate's responses and the progress of the interview, decide whether to ask the next question or end the interview. If you decide the interview has covered enough topics and should conclude, respond with 'END' as your complete message. Otherwise, ask your next question.";
        
        // Add the combined prompt
        systemMessages.push({ role: "system", content: basePrompt + endingInstructions });
        
        // Always include workspace content if available
        if (workspaceContext) {
          systemMessages.push({ role: "system", content: "Project workspace content: " + workspaceContext });
        }
        
        // Construct the payload with all messages using the standardized format
        const payload = {
          "payload": {
            "messages": [
              ...systemMessages,
              ...chatHistory
            ]
          }
        };
        
        // Check if user message is in payload
        const userMessages = payload.payload.messages.filter(m => m.role === 'user');
        console.log(`User messages in payload: ${userMessages.length}`);
        if (userMessages.length > 0) {
          const lastUserMsg = userMessages[userMessages.length - 1];
          console.log(`Last user message in payload: ${lastUserMsg.content.substring(0, 30)}...`);
        } else {
          console.warn('No user messages found in payload!');
        }
        
        // Send message to extension
        vscode.postMessage({
          command: 'chatMessage',
          payload: payload,
          instanceId
        });
        
        // Clear input
        chatInput.value = '';
      });
      
      // Start interview button handler
      startInterviewBtn.addEventListener('click', () => {
        console.log('Start interview button clicked');
        startInitialInterview();
      });

      // Final interview button handler
      startFinalInterviewBtn.addEventListener('click', () => {
        console.log('Start final interview button clicked');
        
        // If we're in the project phase, make sure to handle the transition properly
        if (currentInterviewPhase === 'project') {
          // Stop the project timer if it's running
          if (projectTimerInterval) {
            clearInterval(projectTimerInterval);
          }
          
          // Hide the project timer
          projectTimerContainer.classList.remove('visible');
        }
        
        startFinalInterview();
      });

      // Start the final interview
      function startFinalInterview() {
        if (finalInterviewStarted) {
          console.log('Final interview already started');
          return;
        }
        
        // Proceed with starting the final interview immediately
        // Clear existing chat history for display purposes
        messagesContainer.innerHTML = '';
        chatHistory = [];
        
        // Mark final interview as started
        finalInterviewStarted = true;
        currentInterviewPhase = 'final';
        
        // Hide the final interview button container
        finalInterviewContainer.classList.remove('visible');
        
        // Show a system message indicating the start of the final interview
        appendMessage('system', 'Final Interview Started', true);
        
        // Add a loading message while we wait for the AI's first question
        const loadingMessageId = 'loading-message';
        const loadingMessage = document.createElement('div');
        loadingMessage.id = loadingMessageId;
        loadingMessage.className = 'system-message';
        loadingMessage.textContent = 'Waiting for interviewer to ask the first question...';
        messagesContainer.appendChild(loadingMessage);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
        // Disable the input while waiting for first question
        chatInput.disabled = true;
        chatSubmit.disabled = true;
        
        // Notify the server that the final interview has started
        vscode.postMessage({
          command: 'startFinalInterview',
          instanceId
        });
        
        // Send an automatic first message
        setTimeout(() => {
          // Automatically send the first message from the user
          const initialUserMessage = "I am ready to start the final interview. I have completed the coding project.";
          
          // Add user message to the UI
          appendMessage('user', initialUserMessage);
          
          // Build complete messages array including system prompts and chat history
          const systemMessages = [];
          
          // Add the specific interview prompt if provided
          if (finalPrompt) {
            systemMessages.push({ role: "system", content: finalPrompt + " Based on the candidate's responses and the progress of the interview, decide whether to ask the next question or end the interview. If you decide the interview has covered enough topics and should conclude, respond with 'END' as your complete message. Otherwise, ask your next question." });
          } else {
            // Default system message
            systemMessages.push({ role: "system", content: 'You are a technical interviewer assessing a software engineering candidate. They have been provided with a coding project, which they have now completed. IMPORTANT: Ask only ONE question at a time about their implementation, and wait for their response before asking another question. Start by asking them to explain their overall approach. Based on the candidate\'s responses and the progress of the interview, decide whether to ask the next question or end the interview. If you decide the interview has covered enough topics and should conclude, respond with \'END\' as your complete message. Otherwise, ask your next question.' });
          }
          
          // Always include workspace content if available
          if (workspaceContext) {
            systemMessages.push({ role: "system", content: "Project workspace content: " + workspaceContext });
          }
          
          // Construct the payload with all messages using the standardized format
          const payload = {
              "payload": {
                "messages": [
                  ...systemMessages,
                  { role: "user", content: initialUserMessage, phase: "final" }
                ]
              }
          };
          
          // Send message to extension
          vscode.postMessage({
            command: 'chatMessage',
            payload: payload,
            instanceId,
            phase: 'final'
          });
        }, 500); // Short delay to ensure everything is processed first
      }

      // Update timer display
      function updateTimerDisplay() {
        if (!timerEndTime) {
          console.log('No timer end time available');
          return;
        }
        
        const now = Date.now();
        const timeLeft = Math.max(0, timerEndTime - now);
                
        // Format the time remaining
        const minutes = Math.floor(timeLeft / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        timerElement.textContent = display;
        
        // Check if timer expired
        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          timerElement.textContent = '0:00';
          timerElement.classList.add('expired');
          console.log('Timer expired');
          
          // Get the latest timer status to check if timer is active before auto-starting
          getTimerStatus().then(timerData => {
            if (timerData && timerData.active && !initialInterviewStarted) {
              // Auto-start interview if timer expires, is active, and interview not started
              startInitialInterview();
            }
          }).catch(err => {
            console.error('Error checking timer status before auto-starting interview:', err);
          });
        }
      }

      // Function to update UI based on current phase
      function updateInputStateBasedOnPhase() {
        console.log(`Updating input state based on current phase: ${currentInterviewPhase}`);
        console.log(`Phase flags - Initial: ${initialInterviewStarted}, Initial ended: ${initialInterviewEnded}, Project: ${projectWorkStarted}, Final: ${finalInterviewStarted}, TrulyEnded: ${finalInterviewTrulyEnded}`);
        
        // Check if final interview has permanently ended first
        if (finalInterviewTrulyEnded) {
          console.log('DISABLING CHAT INPUT: Final interview has ended permanently.');
          chatInput.disabled = true;
          chatSubmit.disabled = true;
          return; // Don't proceed with other phase checks
        }
        
        if (projectWorkStarted && !finalInterviewStarted) {
          // We're in the project phase - always disable chat
          console.log('DISABLING CHAT INPUT: In project phase');
          chatInput.disabled = true;
          chatSubmit.disabled = true;
          
          // Show final interview button
          finalInterviewContainer.classList.add('visible');
          
          // Make sure project timer is visible
          projectTimerContainer.classList.add('visible');
          projectTimerContainer.style.display = 'flex';
        } else if (finalInterviewStarted) {
          // Final interview - always enable chat
          console.log('ENABLING CHAT INPUT: In final interview phase');
          chatInput.disabled = false;
          chatSubmit.disabled = false;
          
          // Hide project UI elements
          projectTimerContainer.classList.remove('visible');
          finalInterviewContainer.classList.remove('visible');
        } else if (initialInterviewStarted && !initialInterviewEnded) {
          // Initial interview - enable chat
          console.log('ENABLING CHAT INPUT: In initial interview phase');
          chatInput.disabled = false;
          chatSubmit.disabled = false;
        } else {
          // Not in any interview phase yet
          console.log('DISABLING CHAT INPUT: No interview active');
          chatInput.disabled = true;
          chatSubmit.disabled = true;
        }
      }
      
      // Call this function every time a timer status update is received
      // or any event that might change the phase
      setInterval(updateInputStateBasedOnPhase, 2000); // Check every 2 seconds to be safe

      // Function to submit final report when interview ends
      function submitFinalReport() {
        console.log('FINAL REPORT API: Starting final report submission process...');
        
        // Request fresh workspace content
        vscode.postMessage({ command: 'getWorkspaceContent' });
        
        // Set up a one-time listener for the response with workspace content
        window.addEventListener('message', function workspaceContentListener(event) {
          if (event.data.command === 'workspaceContent') {
            // Remove this one-time listener
            window.removeEventListener('message', workspaceContentListener);
            
            const content = event.data.content;
            if (event.data.error) {
              console.error('FINAL REPORT API: Error getting workspace content:', event.data.error);
              return;
            }
            
            console.log(`FINAL REPORT API: Got workspace content, size: ${content.length} chars`);
            console.log('FINAL REPORT API: Calling submitWorkspaceContent command...');
            
            // Submit the workspace content to the backend for final report generation
            vscode.postMessage({
              command: 'submitWorkspaceContent',
              instanceId,
              content
            });
            
            console.log('FINAL REPORT API: submitWorkspaceContent command sent successfully');
          }
        });
      }
    }());
  </script>
</body>
</html>